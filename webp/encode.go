package webp

import (
	"fmt"
	"image"
	"io"
	"unsafe"

	"git.sr.ht/~jackmordaunt/go-libwebp/lib"
	"modernc.org/libc"
)

// Encode an image into webp with default settings.
func Encode(w io.Writer, m image.Image, opt ...EncodeOption) error {
	var enc Encoder
	for _, op := range opt {
		op(&enc)
	}
	return enc.Encode(w, m)
}

// EncodeOption configures the encoder.
type EncodeOption func(*Encoder)

// Quality in the range (0,1].
func Quality(q float32) EncodeOption {
	return func(enc *Encoder) {
		enc.Quality = q
	}
}

// FIXME: lossless errors out so it's disabled until fixed.
// Lossless will ignore quality.
//func Lossless() EncodeOption {
//	return func(enc *Encoder) {
//		enc.Lossless = true
//	}
//}

// Encoder implements webp encoding of an image.
type Encoder struct {
	// Quality is in the range (0,1]. Values outside of this
	// range will be treated as 1.
	Quality float32
	// Lossless indicates whether to use the lossless compression
	// strategy. If true, the Quality field is ignored.
	Lossless bool

	// out pointer contains the output memory address from webp.
	// Must be a field because stack variables are optimized out
	// by the runtime.
	out uintptr
}

// Encode specified image as webp to w.
// Not threadsafe.
func (enc *Encoder) Encode(w io.Writer, m image.Image) error {
	if enc.Quality <= 0.0 || enc.Quality > 1 {
		enc.Quality = 1.0
	}
	rgba := image.NewRGBA(m.Bounds())
	b := m.Bounds()
	for y := b.Min.Y; y < b.Max.Y; y++ {
		for x := b.Min.X; x < b.Max.X; x++ {
			rgba.Set(x, y, m.At(x, y))
		}
	}
	return enc.encode(w, rgba)
}

func (enc *Encoder) encode(w io.Writer, m *image.RGBA) error {
	return encode(enc, w, m)
}

func encode(enc *Encoder, w io.Writer, m *image.RGBA) error {
	tls := libc.NewTLS()
	defer tls.Close()

	buf, free := unmanage(tls, m.Pix)
	defer free()

	size := lib.Encode(
		tls,
		buf,
		int32(m.Bounds().Dx()),
		int32(m.Bounds().Dy()),
		int32(m.Stride),
		// Function pointers are generated by taking a pointer to
		// a struct who's first field is that function.
		*(*uintptr)(unsafe.Pointer(
			&struct {
				f func(tls *libc.TLS, picture uintptr, rgba uintptr, rgba_stride int32) int32
			}{
				lib.WebPPictureImportRGBA,
			},
		)),
		// quality for libwebp is [0,100].
		float32(enc.Quality*100),
		libc.Bool32(enc.Lossless),
		uintptr(unsafe.Pointer(&enc.out)),
	)

	defer lib.WebPFree(tls, enc.out)
	if size == 0 {
		return fmt.Errorf("encoding webp image: size %d", size)
	}

	if enc.out == 0 {
		return fmt.Errorf("failed to allocate memory; probably errored")
	}

	data := libc.GoBytes(enc.out, int(size))
	if _, err := w.Write(data); err != nil {
		return fmt.Errorf("writing webp data: %w", err)
	}

	return nil
}

// unmanage takes a Go byte slice and returns a copy of it backed by
// unmanaged memory, alongside a function that will free it.
func unmanage(tls *libc.TLS, src []byte) (handle uintptr, free func()) {
	buf := libc.Xcalloc(tls, uint64(len(src)), 1)
	view := libc.GoBytes(buf, len(src))
	copy(view, src)
	return buf, func() { libc.Xfree(tls, buf) }
}
